{"ast":null,"code":"import { ClassTransformer } from '../ClassTransformer';\n/**\n * Return the class instance only with the exposed properties.\n *\n * Can be applied to functions and getters/setters only.\n */\n\nexport function TransformPlainToClass(classType, params) {\n  return function (target, propertyKey, descriptor) {\n    var classTransformer = new ClassTransformer();\n    var originalMethod = descriptor.value;\n\n    descriptor.value = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var result = originalMethod.apply(this, args);\n      var isPromise = !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';\n      return isPromise ? result.then(function (data) {\n        return classTransformer.plainToClass(classType, data, params);\n      }) : classTransformer.plainToClass(classType, result, params);\n    };\n  };\n}","map":{"version":3,"sources":["../../../src/decorators/transform-plain-to-class.decorator.ts"],"names":[],"mappings":"AAAA,SAAS,gBAAT,QAAiC,qBAAjC;AAGA;;;;AAIG;;AACH,OAAM,SAAU,qBAAV,CACJ,SADI,EAEJ,MAFI,EAE0B;AAE9B,SAAO,UAAU,MAAV,EAAuC,WAAvC,EAAqE,UAArE,EAAmG;AACxG,QAAM,gBAAgB,GAAqB,IAAI,gBAAJ,EAA3C;AACA,QAAM,cAAc,GAAG,UAAU,CAAC,KAAlC;;AAEA,IAAA,UAAU,CAAC,KAAX,GAAmB,YAAA;AAAU,UAAA,IAAA,GAAA,EAAA;;WAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAc;AAAd,QAAA,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AAC3B,UAAM,MAAM,GAAQ,cAAc,CAAC,KAAf,CAAqB,IAArB,EAA2B,IAA3B,CAApB;AACA,UAAM,SAAS,GACb,CAAC,CAAC,MAAF,KAAa,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,MAAP,KAAkB,UAA7D,KAA4E,OAAO,MAAM,CAAC,IAAd,KAAuB,UADrG;AAEA,aAAO,SAAS,GACZ,MAAM,CAAC,IAAP,CAAY,UAAC,IAAD,EAAU;AAAK,eAAA,gBAAgB,CAAC,YAAjB,CAA8B,SAA9B,EAAyC,IAAzC,EAAA,MAAA,CAAA;AAAsD,OAAjF,CADY,GAEZ,gBAAgB,CAAC,YAAjB,CAA8B,SAA9B,EAAyC,MAAzC,EAAiD,MAAjD,CAFJ;AAGD,KAPD;AAQD,GAZD;AAaD","sourcesContent":["import { ClassTransformer } from '../ClassTransformer';\nimport { ClassTransformOptions, ClassConstructor } from '../interfaces';\n\n/**\n * Return the class instance only with the exposed properties.\n *\n * Can be applied to functions and getters/setters only.\n */\nexport function TransformPlainToClass(\n  classType: ClassConstructor<any>,\n  params?: ClassTransformOptions\n): MethodDecorator {\n  return function (target: Record<string, any>, propertyKey: string | Symbol, descriptor: PropertyDescriptor): void {\n    const classTransformer: ClassTransformer = new ClassTransformer();\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: any[]): Record<string, any> {\n      const result: any = originalMethod.apply(this, args);\n      const isPromise =\n        !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';\n      return isPromise\n        ? result.then((data: any) => classTransformer.plainToClass(classType, data, params))\n        : classTransformer.plainToClass(classType, result, params);\n    };\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}