{"ast":null,"code":"import { defaultMetadataStorage } from './storage';\nimport { TransformationType } from './enums';\nimport { getGlobal, isPromise } from './utils';\n\nfunction instantiateArrayType(arrayType) {\n  var array = new arrayType();\n\n  if (!(array instanceof Set) && !('push' in array)) {\n    return [];\n  }\n\n  return array;\n}\n\nvar TransformOperationExecutor = function () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function TransformOperationExecutor(transformationType, options) {\n    this.transformationType = transformationType;\n    this.options = options; // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    this.recursionStack = new Set();\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  TransformOperationExecutor.prototype.transform = function (source, value, targetType, arrayType, isMap, level) {\n    var _this = this;\n\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (Array.isArray(value) || value instanceof Set) {\n      var newValue_1 = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];\n      value.forEach(function (subValue, index) {\n        var subSource = source ? source[index] : undefined;\n\n        if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {\n          var realTargetType = void 0;\n\n          if (typeof targetType !== 'function' && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {\n            if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n              realTargetType = targetType.options.discriminator.subTypes.find(function (subType) {\n                return subType.name === subValue[targetType.options.discriminator.property];\n              });\n              var options = {\n                newObject: newValue_1,\n                object: subValue,\n                property: undefined\n              };\n              var newType = targetType.typeFunction(options);\n              realTargetType === undefined ? realTargetType = newType : realTargetType = realTargetType.value;\n              if (!targetType.options.keepDiscriminatorProperty) delete subValue[targetType.options.discriminator.property];\n            }\n\n            if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n              realTargetType = subValue.constructor;\n            }\n\n            if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n              subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(function (subType) {\n                return subType.value === subValue.constructor;\n              }).name;\n            }\n          } else {\n            realTargetType = targetType;\n          }\n\n          var value_1 = _this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\n\n          if (newValue_1 instanceof Set) {\n            newValue_1.add(value_1);\n          } else {\n            newValue_1.push(value_1);\n          }\n        } else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          if (newValue_1 instanceof Set) {\n            newValue_1.add(subValue);\n          } else {\n            newValue_1.push(subValue);\n          }\n        }\n      });\n      return newValue_1;\n    } else if (targetType === String && !isMap) {\n      if (value === null || value === undefined) return value;\n      return String(value);\n    } else if (targetType === Number && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Number(value);\n    } else if (targetType === Boolean && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Boolean(value);\n    } else if ((targetType === Date || value instanceof Date) && !isMap) {\n      if (value instanceof Date) {\n        return new Date(value.valueOf());\n      }\n\n      if (value === null || value === undefined) return value;\n      return new Date(value);\n    } else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Buffer.from(value);\n    } else if (isPromise(value) && !isMap) {\n      return new Promise(function (resolve, reject) {\n        value.then(function (data) {\n          return resolve(_this.transform(undefined, data, targetType, undefined, undefined, level + 1));\n        }, reject);\n      });\n    } else if (!isMap && value !== null && typeof value === 'object' && typeof value.then === 'function') {\n      // Note: We should not enter this, as promise has been handled above\n      // This option simply returns the Promise preventing a JS error from happening and should be an inaccessible path.\n      return value; // skip promise transformation\n    } else if (typeof value === 'object' && value !== null) {\n      // try to guess the type\n      if (!targetType && value.constructor !== Object\n      /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/\n      ) targetType = value.constructor;\n      if (!targetType && source) targetType = source.constructor;\n\n      if (this.options.enableCircularCheck) {\n        // add transformed type to prevent circular references\n        this.recursionStack.add(value);\n      }\n\n      var keys = this.getKeys(targetType, value, isMap);\n      var newValue = source ? source : {};\n\n      if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {\n        if (isMap) {\n          newValue = new Map();\n        } else if (targetType) {\n          newValue = new targetType();\n        } else {\n          newValue = {};\n        }\n      }\n\n      var _loop_1 = function (key) {\n        if (key === '__proto__' || key === 'constructor') {\n          return \"continue\";\n        }\n\n        var valueKey = key;\n        var newValueKey = key,\n            propertyName = key;\n\n        if (!this_1.options.ignoreDecorators && targetType) {\n          if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            var exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key);\n\n            if (exposeMetadata) {\n              propertyName = exposeMetadata.propertyName;\n              newValueKey = exposeMetadata.propertyName;\n            }\n          } else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN || this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n            var exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType, key);\n\n            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n              newValueKey = exposeMetadata.options.name;\n            }\n          }\n        } // get a subvalue\n\n\n        var subValue = undefined;\n\n        if (value instanceof Map) {\n          subValue = value.get(valueKey);\n        } else if (value[valueKey] instanceof Function) {\n          subValue = value[valueKey]();\n        } else {\n          subValue = value[valueKey];\n        } // determine a type\n\n\n        var type = undefined,\n            isSubValueMap = subValue instanceof Map;\n\n        if (targetType && isMap) {\n          type = targetType;\n        } else if (targetType) {\n          var metadata_1 = defaultMetadataStorage.findTypeMetadata(targetType, propertyName);\n\n          if (metadata_1) {\n            var options = {\n              newObject: newValue,\n              object: value,\n              property: propertyName\n            };\n            var newType = metadata_1.typeFunction ? metadata_1.typeFunction(options) : metadata_1.reflectedType;\n\n            if (metadata_1.options && metadata_1.options.discriminator && metadata_1.options.discriminator.property && metadata_1.options.discriminator.subTypes) {\n              if (!(value[valueKey] instanceof Array)) {\n                if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                  type = metadata_1.options.discriminator.subTypes.find(function (subType) {\n                    if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {\n                      return subType.name === subValue[metadata_1.options.discriminator.property];\n                    }\n                  });\n                  type === undefined ? type = newType : type = type.value;\n\n                  if (!metadata_1.options.keepDiscriminatorProperty) {\n                    if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {\n                      delete subValue[metadata_1.options.discriminator.property];\n                    }\n                  }\n                }\n\n                if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n                  type = subValue.constructor;\n                }\n\n                if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                  subValue[metadata_1.options.discriminator.property] = metadata_1.options.discriminator.subTypes.find(function (subType) {\n                    return subType.value === subValue.constructor;\n                  }).name;\n                }\n              } else {\n                type = metadata_1;\n              }\n            } else {\n              type = newType;\n            }\n\n            isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;\n          } else if (this_1.options.targetMaps) {\n            // try to find a type in target maps\n            this_1.options.targetMaps.filter(function (map) {\n              return map.target === targetType && !!map.properties[propertyName];\n            }).forEach(function (map) {\n              return type = map.properties[propertyName];\n            });\n          } else if (this_1.options.enableImplicitConversion && this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            // if we have no registererd type via the @Type() decorator then we check if we have any\n            // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n            var reflectedType = Reflect.getMetadata('design:type', targetType.prototype, propertyName);\n\n            if (reflectedType) {\n              type = reflectedType;\n            }\n          }\n        } // if value is an array try to get its custom array type\n\n\n        var arrayType_1 = Array.isArray(value[valueKey]) ? this_1.getReflectedType(targetType, propertyName) : undefined; // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n\n        var subSource = source ? source[valueKey] : undefined; // if its deserialization then type if required\n        // if we uncomment this types like string[] will not work\n        // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n        //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n        // if newValue is a source object that has method that match newKeyName then skip it\n\n        if (newValue.constructor.prototype) {\n          var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n          if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS || this_1.transformationType === TransformationType.CLASS_TO_CLASS) && (descriptor && !descriptor.set || newValue[newValueKey] instanceof Function)) return \"continue\";\n        }\n\n        if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {\n          var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n          var finalValue = void 0;\n\n          if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n            // Get original value\n            finalValue = value[transformKey]; // Apply custom transformation\n\n            finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType); // If nothing change, it means no custom transformation was applied, so use the subValue.\n\n            finalValue = value[transformKey] === finalValue ? subValue : finalValue; // Apply the default transformation\n\n            finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);\n          } else {\n            if (subValue === undefined && this_1.options.exposeDefaultValues) {\n              // Set default value if nothing provided\n              finalValue = newValue[newValueKey];\n            } else {\n              finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);\n              finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);\n            }\n          }\n\n          if (finalValue !== undefined || this_1.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        } else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n          var finalValue = subValue;\n          finalValue = this_1.applyCustomTransformations(finalValue, targetType, key, value, this_1.transformationType);\n\n          if (finalValue !== undefined || this_1.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        }\n      };\n\n      var this_1 = this; // traverse over keys\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n\n        _loop_1(key);\n      }\n\n      if (this.options.enableCircularCheck) {\n        this.recursionStack.delete(value);\n      }\n\n      return newValue;\n    } else {\n      return value;\n    }\n  };\n\n  TransformOperationExecutor.prototype.applyCustomTransformations = function (value, target, key, obj, transformationType) {\n    var _this = this;\n\n    var metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType); // apply versioning options\n\n    if (this.options.version !== undefined) {\n      metadatas = metadatas.filter(function (metadata) {\n        if (!metadata.options) return true;\n        return _this.checkVersion(metadata.options.since, metadata.options.until);\n      });\n    } // apply grouping options\n\n\n    if (this.options.groups && this.options.groups.length) {\n      metadatas = metadatas.filter(function (metadata) {\n        if (!metadata.options) return true;\n        return _this.checkGroups(metadata.options.groups);\n      });\n    } else {\n      metadatas = metadatas.filter(function (metadata) {\n        return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n      });\n    }\n\n    metadatas.forEach(function (metadata) {\n      value = metadata.transformFn({\n        value: value,\n        key: key,\n        obj: obj,\n        type: transformationType,\n        options: _this.options\n      });\n    });\n    return value;\n  }; // preventing circular references\n\n\n  TransformOperationExecutor.prototype.isCircular = function (object) {\n    return this.recursionStack.has(object);\n  };\n\n  TransformOperationExecutor.prototype.getReflectedType = function (target, propertyName) {\n    if (!target) return undefined;\n    var meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n    return meta ? meta.reflectedType : undefined;\n  };\n\n  TransformOperationExecutor.prototype.getKeys = function (target, object, isMap) {\n    var _this = this; // determine exclusion strategy\n\n\n    var strategy = defaultMetadataStorage.getStrategy(target);\n    if (strategy === 'none') strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy\n    // get all keys that need to expose\n\n    var keys = [];\n\n    if (strategy === 'exposeAll' || isMap) {\n      if (object instanceof Map) {\n        keys = Array.from(object.keys());\n      } else {\n        keys = Object.keys(object);\n      }\n    }\n\n    if (isMap) {\n      // expose & exclude do not apply for map keys only to fields\n      return keys;\n    }\n\n    if (!this.options.ignoreDecorators && target) {\n      // add all exposed to list of keys\n      var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n\n      if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n        exposedProperties = exposedProperties.map(function (key) {\n          var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n\n          if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n            return exposeMetadata.options.name;\n          }\n\n          return key;\n        });\n      }\n\n      if (this.options.excludeExtraneousValues) {\n        keys = exposedProperties;\n      } else {\n        keys = keys.concat(exposedProperties);\n      } // exclude excluded properties\n\n\n      var excludedProperties_1 = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n\n      if (excludedProperties_1.length > 0) {\n        keys = keys.filter(function (key) {\n          return !excludedProperties_1.includes(key);\n        });\n      } // apply versioning options\n\n\n      if (this.options.version !== undefined) {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n          return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n        });\n      } // apply grouping options\n\n\n      if (this.options.groups && this.options.groups.length) {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n          return _this.checkGroups(exposeMetadata.options.groups);\n        });\n      } else {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;\n        });\n      }\n    } // exclude prefixed properties\n\n\n    if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n      keys = keys.filter(function (key) {\n        return _this.options.excludePrefixes.every(function (prefix) {\n          return key.substr(0, prefix.length) !== prefix;\n        });\n      });\n    } // make sure we have unique keys\n\n\n    keys = keys.filter(function (key, index, self) {\n      return self.indexOf(key) === index;\n    });\n    return keys;\n  };\n\n  TransformOperationExecutor.prototype.checkVersion = function (since, until) {\n    var decision = true;\n    if (decision && since) decision = this.options.version >= since;\n    if (decision && until) decision = this.options.version < until;\n    return decision;\n  };\n\n  TransformOperationExecutor.prototype.checkGroups = function (groups) {\n    if (!groups) return true;\n    return this.options.groups.some(function (optionGroup) {\n      return groups.includes(optionGroup);\n    });\n  };\n\n  return TransformOperationExecutor;\n}();\n\nexport { TransformOperationExecutor };","map":{"version":3,"sources":["../../src/TransformOperationExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["import { defaultMetadataStorage } from './storage';\nimport { TypeHelpOptions, TypeOptions, ClassTransformOptions, TypeMetadata } from './interfaces';\nimport { TransformationType } from './enums';\nimport { getGlobal, isPromise } from './utils';\n\nfunction instantiateArrayType(arrayType: Function): Array<any> | Set<any> {\n  const array = new (arrayType as any)();\n  if (!(array instanceof Set) && !('push' in array)) {\n    return [];\n  }\n  return array;\n}\n\nexport class TransformOperationExecutor {\n  // -------------------------------------------------------------------------\n  // Private Properties\n  // -------------------------------------------------------------------------\n\n  private recursionStack = new Set<Record<string, any>>();\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(private transformationType: TransformationType, private options: ClassTransformOptions) {}\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  transform(\n    source: Record<string, any> | Record<string, any>[] | any,\n    value: Record<string, any> | Record<string, any>[] | any,\n    targetType: Function | TypeMetadata,\n    arrayType: Function,\n    isMap: boolean,\n    level: number = 0\n  ): any {\n    if (Array.isArray(value) || value instanceof Set) {\n      const newValue =\n        arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS\n          ? instantiateArrayType(arrayType)\n          : [];\n      (value as any[]).forEach((subValue, index) => {\n        const subSource = source ? source[index] : undefined;\n        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n          let realTargetType;\n          if (\n            typeof targetType !== 'function' &&\n            targetType &&\n            targetType.options &&\n            targetType.options.discriminator &&\n            targetType.options.discriminator.property &&\n            targetType.options.discriminator.subTypes\n          ) {\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n              realTargetType = targetType.options.discriminator.subTypes.find(\n                subType =>\n                  subType.name === subValue[(targetType as { options: TypeOptions }).options.discriminator.property]\n              );\n              const options: TypeHelpOptions = { newObject: newValue, object: subValue, property: undefined };\n              const newType = targetType.typeFunction(options);\n              realTargetType === undefined ? (realTargetType = newType) : (realTargetType = realTargetType.value);\n              if (!targetType.options.keepDiscriminatorProperty)\n                delete subValue[targetType.options.discriminator.property];\n            }\n\n            if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n              realTargetType = subValue.constructor;\n            }\n            if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n              subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(\n                subType => subType.value === subValue.constructor\n              ).name;\n            }\n          } else {\n            realTargetType = targetType;\n          }\n          const value = this.transform(\n            subSource,\n            subValue,\n            realTargetType,\n            undefined,\n            subValue instanceof Map,\n            level + 1\n          );\n\n          if (newValue instanceof Set) {\n            newValue.add(value);\n          } else {\n            newValue.push(value);\n          }\n        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          if (newValue instanceof Set) {\n            newValue.add(subValue);\n          } else {\n            newValue.push(subValue);\n          }\n        }\n      });\n      return newValue;\n    } else if (targetType === String && !isMap) {\n      if (value === null || value === undefined) return value;\n      return String(value);\n    } else if (targetType === Number && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Number(value);\n    } else if (targetType === Boolean && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Boolean(value);\n    } else if ((targetType === Date || value instanceof Date) && !isMap) {\n      if (value instanceof Date) {\n        return new Date(value.valueOf());\n      }\n      if (value === null || value === undefined) return value;\n      return new Date(value);\n    } else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Buffer.from(value);\n    } else if (isPromise(value) && !isMap) {\n      return new Promise((resolve, reject) => {\n        value.then(\n          (data: any) => resolve(this.transform(undefined, data, targetType, undefined, undefined, level + 1)),\n          reject\n        );\n      });\n    } else if (!isMap && value !== null && typeof value === 'object' && typeof value.then === 'function') {\n      // Note: We should not enter this, as promise has been handled above\n      // This option simply returns the Promise preventing a JS error from happening and should be an inaccessible path.\n      return value; // skip promise transformation\n    } else if (typeof value === 'object' && value !== null) {\n      // try to guess the type\n      if (!targetType && value.constructor !== Object /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/)\n        targetType = value.constructor;\n      if (!targetType && source) targetType = source.constructor;\n\n      if (this.options.enableCircularCheck) {\n        // add transformed type to prevent circular references\n        this.recursionStack.add(value);\n      }\n\n      const keys = this.getKeys(targetType as Function, value, isMap);\n      let newValue: any = source ? source : {};\n      if (\n        !source &&\n        (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n          this.transformationType === TransformationType.CLASS_TO_CLASS)\n      ) {\n        if (isMap) {\n          newValue = new Map();\n        } else if (targetType) {\n          newValue = new (targetType as any)();\n        } else {\n          newValue = {};\n        }\n      }\n\n      // traverse over keys\n      for (const key of keys) {\n        if (key === '__proto__' || key === 'constructor') {\n          continue;\n        }\n\n        const valueKey = key;\n        let newValueKey = key,\n          propertyName = key;\n        if (!this.options.ignoreDecorators && targetType) {\n          if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType as Function, key);\n            if (exposeMetadata) {\n              propertyName = exposeMetadata.propertyName;\n              newValueKey = exposeMetadata.propertyName;\n            }\n          } else if (\n            this.transformationType === TransformationType.CLASS_TO_PLAIN ||\n            this.transformationType === TransformationType.CLASS_TO_CLASS\n          ) {\n            const exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType as Function, key);\n            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n              newValueKey = exposeMetadata.options.name;\n            }\n          }\n        }\n\n        // get a subvalue\n        let subValue: any = undefined;\n        if (value instanceof Map) {\n          subValue = value.get(valueKey);\n        } else if (value[valueKey] instanceof Function) {\n          subValue = value[valueKey]();\n        } else {\n          subValue = value[valueKey];\n        }\n\n        // determine a type\n        let type: any = undefined,\n          isSubValueMap = subValue instanceof Map;\n        if (targetType && isMap) {\n          type = targetType;\n        } else if (targetType) {\n          const metadata = defaultMetadataStorage.findTypeMetadata(targetType as Function, propertyName);\n          if (metadata) {\n            const options: TypeHelpOptions = { newObject: newValue, object: value, property: propertyName };\n            const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;\n            if (\n              metadata.options &&\n              metadata.options.discriminator &&\n              metadata.options.discriminator.property &&\n              metadata.options.discriminator.subTypes\n            ) {\n              if (!(value[valueKey] instanceof Array)) {\n                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                  type = metadata.options.discriminator.subTypes.find(subType => {\n                    if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                      return subType.name === subValue[metadata.options.discriminator.property];\n                    }\n                  });\n                  type === undefined ? (type = newType) : (type = type.value);\n                  if (!metadata.options.keepDiscriminatorProperty) {\n                    if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                      delete subValue[metadata.options.discriminator.property];\n                    }\n                  }\n                }\n                if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                  type = subValue.constructor;\n                }\n                if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                  subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find(\n                    subType => subType.value === subValue.constructor\n                  ).name;\n                }\n              } else {\n                type = metadata;\n              }\n            } else {\n              type = newType;\n            }\n            isSubValueMap = isSubValueMap || metadata.reflectedType === Map;\n          } else if (this.options.targetMaps) {\n            // try to find a type in target maps\n            this.options.targetMaps\n              .filter(map => map.target === targetType && !!map.properties[propertyName])\n              .forEach(map => (type = map.properties[propertyName]));\n          } else if (\n            this.options.enableImplicitConversion &&\n            this.transformationType === TransformationType.PLAIN_TO_CLASS\n          ) {\n            // if we have no registererd type via the @Type() decorator then we check if we have any\n            // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n            const reflectedType = (Reflect as any).getMetadata(\n              'design:type',\n              (targetType as Function).prototype,\n              propertyName\n            );\n\n            if (reflectedType) {\n              type = reflectedType;\n            }\n          }\n        }\n\n        // if value is an array try to get its custom array type\n        const arrayType = Array.isArray(value[valueKey])\n          ? this.getReflectedType(targetType as Function, propertyName)\n          : undefined;\n\n        // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n        const subSource = source ? source[valueKey] : undefined;\n\n        // if its deserialization then type if required\n        // if we uncomment this types like string[] will not work\n        // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n        //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n\n        // if newValue is a source object that has method that match newKeyName then skip it\n        if (newValue.constructor.prototype) {\n          const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n          if (\n            (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n              this.transformationType === TransformationType.CLASS_TO_CLASS) &&\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function)\n          )\n            //  || TransformationType === TransformationType.CLASS_TO_CLASS\n            continue;\n        }\n\n        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n          const transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n          let finalValue;\n\n          if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n            // Get original value\n            finalValue = value[transformKey];\n            // Apply custom transformation\n            finalValue = this.applyCustomTransformations(\n              finalValue,\n              targetType as Function,\n              transformKey,\n              value,\n              this.transformationType\n            );\n            // If nothing change, it means no custom transformation was applied, so use the subValue.\n            finalValue = value[transformKey] === finalValue ? subValue : finalValue;\n            // Apply the default transformation\n            finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);\n          } else {\n            if (subValue === undefined && this.options.exposeDefaultValues) {\n              // Set default value if nothing provided\n              finalValue = newValue[newValueKey];\n            } else {\n              finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);\n              finalValue = this.applyCustomTransformations(\n                finalValue,\n                targetType as Function,\n                transformKey,\n                value,\n                this.transformationType\n              );\n            }\n          }\n\n          if (finalValue !== undefined || this.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          let finalValue = subValue;\n          finalValue = this.applyCustomTransformations(\n            finalValue,\n            targetType as Function,\n            key,\n            value,\n            this.transformationType\n          );\n          if (finalValue !== undefined || this.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        }\n      }\n\n      if (this.options.enableCircularCheck) {\n        this.recursionStack.delete(value);\n      }\n\n      return newValue;\n    } else {\n      return value;\n    }\n  }\n\n  private applyCustomTransformations(\n    value: any,\n    target: Function,\n    key: string,\n    obj: any,\n    transformationType: TransformationType\n  ): boolean {\n    let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\n\n    // apply versioning options\n    if (this.options.version !== undefined) {\n      metadatas = metadatas.filter(metadata => {\n        if (!metadata.options) return true;\n\n        return this.checkVersion(metadata.options.since, metadata.options.until);\n      });\n    }\n\n    // apply grouping options\n    if (this.options.groups && this.options.groups.length) {\n      metadatas = metadatas.filter(metadata => {\n        if (!metadata.options) return true;\n\n        return this.checkGroups(metadata.options.groups);\n      });\n    } else {\n      metadatas = metadatas.filter(metadata => {\n        return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n      });\n    }\n\n    metadatas.forEach(metadata => {\n      value = metadata.transformFn({ value, key, obj, type: transformationType, options: this.options });\n    });\n\n    return value;\n  }\n\n  // preventing circular references\n  private isCircular(object: Record<string, any>): boolean {\n    return this.recursionStack.has(object);\n  }\n\n  private getReflectedType(target: Function, propertyName: string): Function | undefined {\n    if (!target) return undefined;\n    const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n    return meta ? meta.reflectedType : undefined;\n  }\n\n  private getKeys(target: Function, object: Record<string, any>, isMap: boolean): string[] {\n    // determine exclusion strategy\n    let strategy = defaultMetadataStorage.getStrategy(target);\n    if (strategy === 'none') strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy\n\n    // get all keys that need to expose\n    let keys: any[] = [];\n    if (strategy === 'exposeAll' || isMap) {\n      if (object instanceof Map) {\n        keys = Array.from(object.keys());\n      } else {\n        keys = Object.keys(object);\n      }\n    }\n\n    if (isMap) {\n      // expose & exclude do not apply for map keys only to fields\n      return keys;\n    }\n\n    if (!this.options.ignoreDecorators && target) {\n      // add all exposed to list of keys\n      let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n      if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n        exposedProperties = exposedProperties.map(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n            return exposeMetadata.options.name;\n          }\n\n          return key;\n        });\n      }\n      if (this.options.excludeExtraneousValues) {\n        keys = exposedProperties;\n      } else {\n        keys = keys.concat(exposedProperties);\n      }\n\n      // exclude excluded properties\n      const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n      if (excludedProperties.length > 0) {\n        keys = keys.filter(key => {\n          return !excludedProperties.includes(key);\n        });\n      }\n\n      // apply versioning options\n      if (this.options.version !== undefined) {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n\n          return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n        });\n      }\n\n      // apply grouping options\n      if (this.options.groups && this.options.groups.length) {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n\n          return this.checkGroups(exposeMetadata.options.groups);\n        });\n      } else {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          return (\n            !exposeMetadata ||\n            !exposeMetadata.options ||\n            !exposeMetadata.options.groups ||\n            !exposeMetadata.options.groups.length\n          );\n        });\n      }\n    }\n\n    // exclude prefixed properties\n    if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n      keys = keys.filter(key =>\n        this.options.excludePrefixes.every(prefix => {\n          return key.substr(0, prefix.length) !== prefix;\n        })\n      );\n    }\n\n    // make sure we have unique keys\n    keys = keys.filter((key, index, self) => {\n      return self.indexOf(key) === index;\n    });\n\n    return keys;\n  }\n\n  private checkVersion(since: number, until: number): boolean {\n    let decision = true;\n    if (decision && since) decision = this.options.version >= since;\n    if (decision && until) decision = this.options.version < until;\n\n    return decision;\n  }\n\n  private checkGroups(groups: string[]): boolean {\n    if (!groups) return true;\n\n    return this.options.groups.some(optionGroup => groups.includes(optionGroup));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}